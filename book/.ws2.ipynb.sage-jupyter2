{"backend_state":"init","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-61b78fea-3b5d-42eb-8c5e-ec6a60e09b4c.json","kernel":"python3","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"interpreter":{"hash":"4b16baa96560834d52deaa0a26dd4bf0778d5ef2c475295f51a93ca0a294766a"},"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.8"},"orig_nbformat":4},"trust":true,"type":"settings"}
{"cell_type":"code","exec_count":17,"id":"11b2c5","input":"# Create and plot undirected graph using adjacency matrix\n\nadj_matrix = np.array([[0, 1, 0],\n                      [0, 0, 1],\n                      [1, 0, 0]])\nG2=nx.from_numpy_matrix(adj_matrix)\nplt.figure(figsize=(3,3), dpi=25)\nnx.draw(G2)\n","output":{"0":{"data":{"image/png":"48e36cdc66871569dfa539ee6c5e303152fe06e7","text/plain":"<Figure size 216x216 with 1 Axes>"},"exec_count":17,"metadata":{"image/png":{"height":230,"width":230}},"output_type":"execute_result"}},"pos":2,"type":"cell"}
{"cell_type":"code","exec_count":206,"id":"e16c48","input":"{\n    \"tags\": [\n        \"remove-output\"\n    ]\n}\n\nimport pandas as pd\nimport numpy as np\n\nhermfulledgelist = pd.read_csv('herm_full_edgelist.csv')\n\ndf = hermfulledgelist[hermfulledgelist.Type=='chemical']\ndf = df.apply(lambda x: x.astype(str).str.strip())\nG = nx.from_pandas_edgelist(df, 'Source', 'Target', create_using=nx.Graph)\nG = G.to_directed()\nplt.figure(1,figsize=(10,10))\ndraw(G, node_size=5, width=0.5)\nplt.show()\n","output":{"0":{"data":{"image/png":"877a9cd9ae4e8d545584496df411f237798109a7","text/plain":"<Figure size 720x720 with 1 Axes>"},"exec_count":206,"output_type":"execute_result"}},"pos":9,"type":"cell"}
{"cell_type":"code","exec_count":207,"id":"4893e5","input":"{\n    \"tags\": [\n        \"remove-output\"\n    ]\n}\n\nnodes = list(G.nodes)\ni = nodes.index('SMDDL')\n\nM = nx.to_numpy_matrix(G)\ndownstream = bfs(M,i)\nJ = nx.subgraph(G, [nodes[x] for x in downstream])\ndraw(J, node_size=5, width=0.5)\nplt.show()","output":{"0":{"data":{"image/png":"74f7c37d340c5193af24c48aa0d09a4e4fffc97b","text/plain":"<Figure size 432x288 with 1 Axes>"},"exec_count":207,"output_type":"execute_result"}},"pos":11,"type":"cell"}
{"cell_type":"code","exec_count":21,"id":"17443d","input":"import networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Create and plot undirected graph using edge list\n\nG1 = nx.Graph()\nedge_list = [(0, 1), (1, 2), (2, 0)]\nG1.add_edges_from(edge_list)\nplt.figure(figsize=(3,3), dpi=25)\nnx.draw(G1)","output":{"0":{"data":{"image/png":"8e7572319190a8eff6421c1020c6c12d038c217e","text/plain":"<Figure size 75x75 with 1 Axes>"},"exec_count":21,"metadata":{"image/png":{"height":80,"width":80}},"output_type":"execute_result"}},"pos":1,"type":"cell"}
{"cell_type":"code","exec_count":220,"id":"0abbd7","input":"def clustering_coefficient(G,i):\n    # Returns clustering coefficient of node\n    #  i (in string form) of simple directed graph\n    succ = set(G.successors(i))\n    pre = set(G.predecessors(i))\n    neighbours = succ.union(pre)\n    H = nx.subgraph(G, neighbours)\n    n = H.number_of_nodes()\n    m = H.number_of_edges()\n    result = m/(n**2-n)\n    return result\n","output":{"0":{"data":{"text/plain":"0.15433673469387754"},"exec_count":220,"output_type":"execute_result"}},"pos":15,"type":"cell"}
{"cell_type":"code","exec_count":230,"id":"1428c6","input":"def avg_path_length(G):\n    d = dict(nx.all_pairs_shortest_path_length(G))\n    n = len(d)\n    nested_list_d = [list(d.values())[x].values() for x in range(n)]\n    flat_list_d= [val for sublist in nested_list_d for val in sublist]\n    result = np.mean(flat_list_d)\n    return result\n","output":{"0":{"data":{"text/plain":"5"},"exec_count":230,"output_type":"execute_result"}},"pos":13,"type":"cell"}
{"cell_type":"code","exec_count":3,"id":"210ee3","input":"{\n    \"tags\": [\n        \"hide-output\"\n    ]\n}\n\nimport networkx as nx\nimport matplotlib.pyplot as plt\nfrom networkx.drawing.nx_pylab import draw\n\n# Create a graph from an edge list \nedges = [(1, 2), (2, 3), (3, 1), (4,5)]\nG = nx.DiGraph()\nG.add_edges_from(edges)\n\n# Determine its connected components and color the largest one\nlargest_cc = max(nx.weakly_connected_components(G), key=len)\nprint('Largest connected component:',largest_cc)\ncolor_map = []\nfor node in G:\n    if node in largest_cc:\n        color_map.append('red')\n    else:\n        color_map.append('blue')\ndraw(G, with_labels=True, node_color=color_map)\nplt.show()","output":{"0":{"name":"stdout","output_type":"stream","text":"{1, 2, 3}\n"},"1":{"data":{"image/png":"5e8a06ae0aa54e4eb8a9c3a7f8ae16ec6904f335","text/plain":"<Figure size 432x288 with 1 Axes>"},"exec_count":3,"output_type":"execute_result"}},"pos":7,"type":"cell"}
{"cell_type":"markdown","id":"1cc3dd","input":"Refer to the following URL for more documentation:\n<https://networkx.org>","pos":3,"type":"cell"}
{"cell_type":"markdown","id":"216574","input":"The **clustering coefficient** of a node $\\gamma(\\mu)$ measures how many edges exist between a node’s neighbours, where the $n$ **neighbours** of a node $\\mu$ are the nodes directly connected to $\\mu$ in either direction. The nodes’s clustering coefficient is defined as the ratio of actually existing connections between the $n$ neighbours and the maximal number of such connections possible. If the $n$ neighbours are connected to each other by $m$ edges, then the clustering coefficient $ \\gamma(\\mu) = m/(n^2 −n)$. (Note that the clustering coefficient does not exist for nodes that have fewer than 2 neighbours). The **global clustering coefficient** is the average cluster index over all nodes (where it is defined).","pos":14,"type":"cell"}
{"cell_type":"markdown","id":"313c26","input":"# Manipulating graphs with Python\n\nPython has many functions for manipulating and investigating graphs. For example, the following Python code demonstrates two\nways to create a graph representing a directed 3-cycle.","pos":0,"type":"cell"}
{"cell_type":"markdown","id":"5e48af","input":"## Question 1\n\nUse NetworkX to plot a *directed* graph of the [egg-laying circuit](egg-laying-circuit).","pos":4,"type":"cell"}
{"cell_type":"markdown","id":"651ab1","input":"### Question 1\n1.  Draw a picture (by hand) of a connected simple digraph with ten nodes and three strongly connected components.\n1. Use Python to:\n    1. Create and plot your graph.\n    1. Colour the nodes according to their strongly connected component.\n    1. Determine the pair of nodes i, j with the greatest path distance. Hint: the following functions gives the general workflow however you will need to add some lines to find the greatest path distance. <br>\n        *d = dict(nx.all_pairs_shortest_path_length(G))* <br>\n        *m = max(d)* <br>\n        *i,j = np.where(d==m)* \n    1. Determine the shortest path between i and j and increase the width of its edges to 2 points.\n\nIn this workshop we will start investigating real nervous system connectivity data. To do this we will need to import the data into Python.\n\n## Importing Data into Python\n\nWe are used to storing and manipulating data in Python Numpy arrays. However, arrays may only be used for storing numerical data. For other types of data (such as text) Python has a different package called Pandas which works with **dataframes**. Much like a database table, Pandas dataframes store rows of data consisting of multiple heterogeneous data types. In the next question we will import connectivity data of the C-Elegans into a Pandas dataframe.\n\n### Question 2\n1. We would like to import the *herm_full_edgelist.csv* file (available on Moodle). \n1. Pandas has a function called *read_csv(filename)* which is used for importing csv files like the one above.\n1. Use this function and assign a variable (e.g. hermfulledgelist) to the result (make sure the file has been added to your working directory so Pandas can find it).\n1. A dataframe is created and you can view it with *print(hermfulledgelist)* (replacing with the variable name you have chosen if different). If you would like to only view the first few lines of the dataframe you can use *print(hermfulledgelist.head())*.\n\n```{admonition} What is a CSV file?\n```\nWe would like to build a Python graph representing the connectivity data. To do this, we need to select rows of type ‘chemical’ then extract the Source and Target columns.","pos":8,"type":"cell"}
{"cell_type":"markdown","id":"989b4a","input":"### Example\n\nFigure 1: Directed graph and a histogram of its outdegree distribution. Its average connection density is $12/(6^2−6) = 0.4$. The cluster index of node 1 is $\\gamma(1) = 6/(5^2−5) = 0.4$ since it has 5 neighbours connected by 6 edges.\n\n### Question 7\n1. Recall that $K_n$ is the complete directed graph with $n$ nodes. Determine the average path length and global clustering coefficient of $K_n$.\n2. What does the global clustering coefficient indicate about a graph? (See [1])\n\n## Ring Lattices\n\nA **ring lattice** graph consists of $N$ nodes arranged in a ring such that each node is connected to each of its $k$ closest neighbours. For a directed ring lattice, the edges exist in both directions.\n\n### Question 8\n\nFor an directed order $N$ ring lattice with $k = 4$:\n1. Calculate the global clustering coefficient. \n1. Calculate the average path length.\n\nFigure 2: Directed ring lattice with $N = 10$ and $k = 4$. Every node is connected to its 4 nearest neighbours in both directions.\n\n## References\n\n[1] Sporns, Olaf. Graph theory methods for the analysis of neural connectivity patterns. In *Neuroscience Databases*. Springer, Boston, MA, 2003. pp 171-185.\n\n[2] Fornito, A., Zalesky, A., and Bullmore, E. *Fundamentals of Brain Network Analysis*. Academic Press, 2016.","pos":16,"type":"cell"}
{"cell_type":"markdown","id":"aa6c29","input":"### Question 3\n1. Use the above code to generate a graph of the hermaphrodite C-Elegans neural circuit. Plot the graph, then print the number of nodes and number of edges.\n1. What do you think the weight column represents? Adapt the code so that only connections with a weight of 10 or more are included. How did the number of nodes and edges change?\n\nLet’s call the the C-Elegans circuit with minimum connection weight 10 ‘CE-10’. The graph of CE-10 consists of several connected components. Let’s discard everything apart from the largest one.\n\n### Question 4\n1. Determine and plot the largest connected component of CE-10 (you will need\nto use subgraph).\n1. How many components are there in CE-10?\n1. How many neurons are in the second largest component of CE-10?\n1. Plot the second largest component of CE-10. (Hint: use len(c) for c in sorted(nx.weakly_connected_components(G), key=len) to order the components by size)\n\nWe say that one neuron is **downstream** of another if it can be reached by following synaptic connections. The downstream neurons are ones that can be influenced by activity of the upstream neuron. Let’s find all neurons downstream of neuron ‘SMDDL’ by following paths from its node in the graph.\n","pos":10,"type":"cell"}
{"cell_type":"markdown","id":"b13be8","input":"### Question 5\n1. Use the above code to plot the graph of the neurons downstream of SMDDL.\n1. Plot the graph of the neurons upstream of SMDDL. (Hint: reverse the edges of the graph).\n1. What do you think the upstream and downstream neurons represent in terms of brain function?\n\n\n\n","pos":12,"type":"cell"}
{"cell_type":"markdown","id":"b9dc38","input":"**Calculate distance matrix between node pairs**\n```python\n# For unweighted graph\nnx.all_pairs_shortest_path(G) # calculates shortest paths between all nodes\nnx.all_pairs_shortest_path_length(G) # lengths of shortest paths between nodes \n# And similarly for weighted graphs:\nnx.all_pairs_dijkstra_path(G)\nnx.all_pairs_dijkstra_path_length(G)\n```\n\n**Find strongly and weakly connected components**\n``` python\nnx.weakly_connected_components(G)\nnx.strongly_connected_components(G)\n# Get number of strongly/weakly connected components:\nnx.number_strongly_connected_components(G)\nnx.number_weakly_connected_components(G)\n```\n**Find shortest path between nodes**\n```python\nnx.shortest_path(G, 'source node inputted here', 'target node inputted here')\n```\n\n**Plot graph and set node colour**\n```python\n# Use the networkx drawing modules:\nfrom networkx.drawing.nx_pylab import draw, draw_networkx\ndraw(G, node_color='b') # can change colour and other properties here\ndraw_networkx(G) # an alternative function that works the same as draw\nnx.relabel_nodes(G,mapping={0:1,1:2,2:3}) # can relabel nodes so the ordering is the same as in matlab\n\n# Use matplotlib to display the network\nimport matplotlib.pyplot as plt\nplt.show()\n```\n\n### Example\n","pos":6,"type":"cell"}
{"cell_type":"markdown","id":"fff26c","input":"## Useful Python graph functions\n\n``` python\nimport networkx as nx\n```\n**Create directed graph from edge list or adjacency matrix**\n\n``` python\n# Use here the class DiGraph from module networkx for directed graphs:\nG = nx.DiGraph()\n# For graph from adjacency matrix use the function:\nnx.from_numpy_matrix('adjacency matrix inputted here', create_using=G)\n# For graph from edge list use function:\nG.add_edges_from('edge list inputted here')\n```\n**Create undirected graphs**\n``` python\n# Similarly to directed graphs, first initialise an undirected graph:\nG = nx.Graph()\n# Using an adjacency matrix:\nnx.from_numpy_matrix('adjacency matrix inputted here', create_using=G)\n# Using an edge list:\nG.add_edges_from('edge list inputted here')\n```\n\n**Get number of nodes and edges**\n``` python\nG.number_of_edges() # either returns the number of edges between two nodes if specified or the total number of edges\nG.number_of_nodes() # returns number of nodes\n```\n\n**Remove loops and multiple edges**\nThere is no straight forward way to simplify a graph with networkx in Python.\nHere are a few functions which are useful workarounds.\n```python\nG.add_edges_from(list(set('edgelist'))) # use of set removes any duplicates in a given list\nG.remove_edges_from(nx.selfloop_edges(G)) # removes loops\nG.is_simple_path('nodes') # checks if the nodes inputted form a simple path \n```\n\n**Create a subgraph**\n```python\nG.subgraph('nodes inputted here')\n```","pos":5,"type":"cell"}
{"id":0,"time":1642758362910,"type":"user"}
{"last_load":1642758363128,"type":"file"}